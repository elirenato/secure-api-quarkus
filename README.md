# Secure API Quarkus

This project is a Java REST API application that was configured to use [Keycloak](https://www.keycloak.org) as access management.

It was bootstrapped using [Quarkus](https://quarkus.io/) with the following extensions/dependencies:
- RESTEasy reactive.
- Hibernate ORM Panache and Hibernate Validator.
- Liquibase (With PostgreSQL as the database).
- OIDC to enable the integration with Keycloak.
- JUnit5 with Mockito to test.
- Test Security to mock the Authentication and Roles for test purposes.
- [TestContainers](https://www.testcontainers.org/) to run tests in an isolated PostgresSQL database.
- Jacoco to generate the coverage test report.
- Container Image Jib to build the image that will be pulled by Kubernetes.
- Kubernetes, to generate the resources needed to deploy on Kubernetes.
- [Java Faker](http://github.com/DiUS/java-faker) to generate test data.
- [Lombok](https://projectlombok.org/) to keep the code clean.

## Directory Structure

This project follows the default Java structure `/src/main`.

- `/src/main/java` - The Java code.
- `/src/main/test` - The Java test code.
- `/src/main/docker` - The Docker files that were generated by Quarkus can be used to deploy the application depending on how you build the application (JVM, jar, or Native with GraalVM).
- `/src/main/docker/keycloak`: The Docker files to build the Keycloak Docker image required for this project.
- `/src/main/jenkins` - Jenkins file and resources that are used to set up the pipeline to build and deploy the application.

## Running tests

By default, the tests use the Testcontainers to start a PostgreSQL container, so, you can just run:

`./mvnw test`

It's possible to run the tests without Testcontainers using the command:

`./mvnw test -Dtest.containers.disabled`

But you must have a PostgresSQL container running and the `app_test` database already created. 

See the `src/test/resource/application.properties` to see the credentials used by the tests.

## Before run the application in dev mode

### Keycloak and PostgreSQL  

This application depend on these services, so, you must have them running.

For dev purpose, you can use the bash script `./start-keycloak.sh` to start Docker containers with these services. 
The content of the script is below:
```bash
docker-compose -f src/main/docker/keycloak/docker-compose.yaml --env-file=src/main/docker/keycloak/.env build
docker-compose -f src/main/docker/keycloak/docker-compose.yaml --env-file=src/main/docker/keycloak/.env up -d
docker-compose -f src/main/docker/keycloak/docker-compose.yaml --env-file=src/main/docker/keycloak/.env logs -f
```

The Keycloak will be available at `http://localhost:8080`.

To stop the containers you can use the script `./stop-keycloak.sh`. The content of the script is show below:
```bash
docker-compose -f src/main/docker/keycloak/docker-compose.yaml --env-file=src/main/docker/keycloak/.env down
```

### Keycloak Realm

To complete the setup of Keycloak, you also need to configure a Realm to test the application.

[Configure a new realm](https://elibarbosa.dev/using-keycloak-to-secure-applications/#configure-realm).

Double-check the following properties of the `src/main/resource/application.properties` file. 
The values of them must match with the values used to create the test realm.

```
auth-server-url=${QUARKUS_OIDC_AUTH-SERVER-URL:http://localhost:8080/auth/realms/app}
quarkus.oidc.client-id=${QUARKUS_OIDC_CLIENT-ID:secure-api-quarkus}
quarkus.oidc.credentials.secret=${QUARKUS_OIDC_CREDENTIALS_SECRET:rQGYWLVWPNd8brFCqUfodNHv1SUfZ6We}
```

### Run the application in dev mode

Finally, it's possible to run the application:
```bash
./mvnw compile quarkus:dev
```

PS: Quarkus ships with a Dev UI, which is available in dev mode only at http://localhost:8080/q/dev/.

## Packaging and running the application

The application can be packaged using:
```bash
./mvnw package
```

## Deploying application to Kubernetes

The application is deployed to Kubernetes using Jenkins:

1. The first stage, run the tests with coverage report.
2. The second stage, package the application, build an image and push the image to a private Docker Registry repository.
3. The last stage, uses the Kubernetes resources generated by Quarkus to deploy the application.

See the [Jenkinsfile](./src/main/jenkins/Jenkinsfile) for more details:

PS: The Jenkins agent to build this project is Docker. The image created for Jenkins agent, uses a GraalVM JDK, 
as I intend to do some tests building a native executable in the future.

## Creating a native executable

**PS: NOT TESTED YET**

You can create a native executable using: 
```shell script
./mvnw package -Pnative
```

Or, if you don't have GraalVM installed, you can run the native executable build in a container using: 
```shell script
./mvnw package -Pnative -Dquarkus.native.container-build=true
```

You can then execute your native executable with: `./target/secure-api-quarkus-1.0.0-SNAPSHOT-runner`

If you want to learn more about building native executables, please consult https://quarkus.io/guides/maven-tooling.
