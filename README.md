# Secure Api Quarkus Project

This project uses Quarkus, the [Supersonic Subatomic Java Framework](https://quarkus.io/).

## Before running the application

Before running the application with dev profile or running tests, make sure the Keycloak and PostgreSQL images are running.

Entre inside the folder:
`cd src/main/docker/keycloak`

Build the image:
`docker-compose --env-file=.env build`

Run the image as a container:
`docker-compose --env-file=.env up -d`

The Keycloak will be available at `http://localhost:8080`.

### Create the Keycloak Realm for test

See the steps on this page to configure the Keycloak realm to test the application.

[Configure a new realm](https://elibarbosa.dev/using-keycloak-to-secure-applications/#configure-realm).

## Running tests

`./mvnw test`

or 

`./mvnw test -Dtest.containers.disabled`

To disable the TestContainers, but you must have a Postgres service running and the `app_test` database created. 
See the `src/test/resource/application.properties` to see the credentials used by the test profile.

## Running the application in dev mode

You can run your application in dev mode that enables live coding using:
```shell script
./mvnw compile quarkus:dev
```

> **_NOTE:_**  Quarkus now ships with a Dev UI, which is available in dev mode only at http://localhost:8080/q/dev/.

## Packaging and running the application

The application can be packaged using:
```shell script
./mvnw package
```

## Deploying application to Kubernetes

The application is deployed to Kubernetes using Jenkins:

1. The first stage, run the tests with coverage report.
2. The second stage, package the application, build an image and push the image to a private Docker Registry repository.
3. The last stage, uses the Kubernetes resources generated by Quarkus to deploy the application.

See the [Jenkinsfile](./src/main/jenkins/Jenkinsfile) for more details:

PS: The Jenkins agent to build this project is Docker. The image created for Jenkins agent, uses a GraalVM JDK, 
as I intend to do some tests building a native executable.

## Creating a native executable

**PS: NOT TESTED YET**

You can create a native executable using: 
```shell script
./mvnw package -Pnative
```

Or, if you don't have GraalVM installed, you can run the native executable build in a container using: 
```shell script
./mvnw package -Pnative -Dquarkus.native.container-build=true
```

You can then execute your native executable with: `./target/secure-api-quarkus-1.0.0-SNAPSHOT-runner`

If you want to learn more about building native executables, please consult https://quarkus.io/guides/maven-tooling.

## Related Guides

- RESTEasy Reactive ([guide](https://quarkus.io/guides/resteasy-reactive)): A JAX-RS implementation utilizing build time processing and Vert.x. This extension is not compatible with the quarkus-resteasy extension, or any of the extensions that depend on it.
- Hibernate ORM with Panache ([guide](https://quarkus.io/guides/hibernate-orm-panache)): Simplify your persistence code for Hibernate ORM via the active record or the repository pattern
- Liquibase ([guide](https://quarkus.io/guides/liquibase)): Handle your database schema migrations with Liquibase
- OpenID Connect ([guide](https://quarkus.io/guides/security-openid-connect)): Verify Bearer access tokens and authenticate users with Authorization Code Flow
- Hibernate Validator ([guide](https://quarkus.io/guides/validation)): Validate object properties (field, getter) and method parameters for your beans (REST, CDI, JPA)

## Provided Code

### RESTEasy Reactive

Easily start your Reactive RESTful Web Services

[Related guide section...](https://quarkus.io/guides/getting-started-reactive#reactive-jax-rs-resources)
